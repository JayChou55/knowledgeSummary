ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。一个很好的事务处理系统，必须具备这些标准特性：

隔离级别：

READ UNCOMMITTED（未提交读）

　　在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。
	事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。
	这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

READ COMMITTED（提交读 默认:oracle）

　　大多数数据库系统的默认隔离级别都是READ COMMTTED（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能"看见"已经提交的事务所做的修改。
	换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候叫做不可重复读（nonrepeatble read），因为两次执行同样的查询，可能会得到不一样的结果

REPEATABLE READ(可重复读 默认:mysql)

　　REPEATABLE READ解决了脏读的问题。该隔离级别保证了在同一个事务中多次读取同样记录结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。
	幻读，指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。
	InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。

SERIALIZABLE（可串行化）

　　SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。
	简单来说，SERIALIZABLE会在读取每一行数据都加锁，所以可能导致大量的超时和锁争用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。


Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。
所以Oracle不支持脏读，即Oracle中不允许一个会话读取其他事务未提交的数据修改结果，从而防止了由于事务回滚发生的读取不正确。




读提交，不可重复读，个人理解是针对一条记录，因为T1事务中读取一条记录时未加锁，此时T2事务可以修改该记录，当T1第一次读取后，并使用该值做了一些校验正准备在此读取做更新操作时，发现数据和之前第一次读的不一致了。

例如，你在ATM取钱，先查询了一下余额发现还有10块钱，你正准备取出买东西时，10块钱却被你女朋友利用网上银行扣走了，在你查完余额转到取钱时，ATM发现余额不足了。前后两次你看到的余额不同，造成了不可重复读或者虚读。

可重复读，在一条记录上的操作是，不能读取已由其它事务修改了但是未提交的行，其它任何事务也不能修改在当前事务完成之前由当前事务读取的数据。但是对于其它事务插入的新行数据，当前事务第二次访问表行时会检索这一新行。
因此，这一个隔离级别的设置解决了 Non-Repeatable Reads 不可重复读取的问题，但是避免不了 Phantom Reads 幻读。

例如：事务T1在读取R1和修改R2，此时T2不能够读取R2也不能修改R1，这样T2的操作就不会影响到T1的操作，但是，如果T1中含有一个统计某个范围内记录数量的操作，而T2在此时正好在此范围内插入了一条记录，则会草成T1的幻读，
即第一次读此范围内一共2条数据，而在次读的时候却有了3条数据。


个人感觉，两者的的区别是，读提交在读取一条记录时会出现不可重复读，而可重复度通过对事务里面的读写操作加锁，解决了度提交的问题，但是对统计某个范围内的记录数量，还是会产生幻读。



					脏读	不可重复读	幻读
Read uncommitted	√			√		 √
Read committed		×			√		 √
Repeatable read		×			×	 	 √
Serializable		×			×		 ×




users： id 主键1、T1：select * from users where id = 1;
2、T2：insert into `users`(`id`, `name`) values (1, 'big cat');
3、T1：insert into `users`(`id`, `name`) values (1, 'big cat');
T1 ：主事务，检测表中是否有 id 为 1 的记录，没有则插入，这是我们期望的正常业务逻辑。
T2 ：干扰事务，目的在于扰乱 T1 的正常的事务执行。
在 RR 隔离级别下，1、2 是会正常执行的，3 则会报错主键冲突，对于 T1 的业务来说是执行失败的，这里 T1 就是发生了幻读，
因为T1读取的数据状态并不能支持他的下一步的业务，见鬼了一样。在 Serializable 隔离级别下，1 执行时是会隐式的添加 gap 共享锁的，
从而 2 会被阻塞，3 会正常执行，对于 T1 来说业务是正确的，成功的扼杀了扰乱业务的T2，对于T1来说他读取的状态是可以拿来支持业务的。
所以 mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，
之前的检测读获取到的数据如同鬼影一般。这里要灵活的理解读取的意思，第一次select是读取，第二次的 insert 其实也属于隐式的读取，
只不过是在 mysql 的机制中读取的，插入数据也是要先读取一下有没有主键冲突才能决定是否执行插入。不可重复读侧重表达 读-读，
幻读则是说 读-写，用写来证实读的是鬼影。